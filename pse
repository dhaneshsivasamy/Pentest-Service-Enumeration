#!/bin/bash
#
# Author: Steve Stonebraker
# Github: https://github.com/ssstonebraker/Pentest-Service-Enumeration
# Description: Store/retrieve a list of pentest commands to run against the specified service
#
#
#set -eo pipefail
chars='[ !"#$&()*,;<>?\^`{|}]'
for arg
do
    if [[ $arg == *\'* ]]
    then
        arg=\""$arg"\"
    elif [[ $arg == *$chars* ]]
    then
        arg="'$arg'"
    fi
    allargs+=("$arg")    # ${allargs[@]} is to be used only for printing
done
printf '%s\n' "${allargs[*]}" > /tmp/pse.tmp


VERSION=0.0.1
####################################
# Exit if program echo does not exist (this allows us to do one line if statements)
[ ! -x "$(which echo)" ] && exit 1
########################################
print_version () {
  echo "Pentest Service Enumeration: $VERSION"
}
# pretty printing functions
LIGHT_CYAN="\e[96m"
NO_COLOR="\x1B[0m"
ITALICS="\x1B[01;3m"
function print_status { echo -e "\x1B[01;34m[*]\x1B[0m $1"; }
function print_good { echo -e "\x1B[01;32m[*]\x1B[0m $1"; }
function print_error { echo -e "\x1B[01;31m[*]\x1B[0m $1"; }
function print_notification { echo -e "\x1B[01;33m[*]\x1B[0m $1"; }
function print_notify { echo -e "\x1B[01;33m[*]\x1B[0m $1"; }
function print_info { echo -e "$LIGHT_CYAN[-]$NO_COLOR $1"; }
function print_italics { echo -e "$ITALICS$1$NO_COLOR"; }
ansi()      { echo -e "\e[${1}m${*:2}\e[0m"; }
bold()      { ansi 1 "$@"; }
italic()    { ansi 3 "$@"; }
underline()   { ansi 4 "$@"; }
strikethrough() { ansi 9 "$@"; }
red()       { ansi 31 "$@"; }
function printline { hr=----------------------------------------------------------------------------------------------------
printf '%s\n' "${hr:0:${COLUMNS:-$(tput cols)}}"
}

####################################
# print message and exit program
function die { print_error "$1" >&2;exit 1; }
######################################## 
SERVICE=$1
if [[ "$SERVICE" ==  "-v" ]]; then
    _V=1
    SERVICE=$2
else
    _V=0
fi
if [[ "$SERVICE" ==  "-a" ]]; then
    _A=1
    SERVICE=$2
else
    _A=0
fi
checkForSingleQuotes () {
ALLARGS=$(cat /tmp/pse.tmp)
if [[ $ALLARGS =~ ^.*\'.*\'$ ]]; then
        return 0
else
        die "Your command must have single quotes around it!"
        exit
fi
}


FULLCMD=${@:2}
SERVICES="$HOME/.pse"
SERVICEFILE="$HOME/.pse/$SERVICE"

function verify_directory_services_exists {
  # Make sure services directory exists
  if [ -z "$HOME" ]; then
     print_error "\$HOME variable not defined!"
     print_notification "Exiting"
     exit 1
  fi
  if [ ! -d $SERVICES ]; then
    print_notification "$SERVICES not found"
    mkdir $SERVICES && print_good "Created $SERVICES"  
  fi

  [ ! -d $SERVICES ] && print_error "Unable to create directory $SERVICES, exiting" && exit 1
}

function usage1 {
  print_version
  printline
  bold "LISTING EXISTING COMMANDS:"
  echo "Usage: pse <service-name> (Ex: ftp, rdp, http)"
  echo " -v: verbose - print command description"
  underline "Examples"
  print_good "pse ftp"
  print_good "pse -v ftp (for verbose)"
}

function usage2 {
  printline
  bold "STORING A NEW COMMAND WITH ARGUMENTS"
  echo "Usage: pse -a <service-name> '<command> <arg1> <argX>'"
  print_italics "note: You must use single quotes around your command"
  underline "Examples"
  print_good "pse -a rpc 'rpcinfo \$IP'"
  print_good "pse -a smb 'smbexec.py \$HOST/\$USERNAME:\$PASSWORD@\$IP'"
  printline
}
function usage  {
  usage1
  usage2
}

function print_service {
  if [[  "$SERVICE" ==  "-h" ]]; then
    usage
    exit
  fi 
  if [[  "$SERVICE" ==  "-l" ]]; then
    print_info "pse stored service location: ${SERVICES}"
    print_notify "listing all services that have pse stored commands"
    ls ${SERVICES} | grep -v "sorted"
    exit
  fi 
  if [ ! -f $SERVICEFILE ]; then
  [[ ! -z "$SERVICE" ]] && print_error "Documentation does not exist for $SERVICE, please add some"
  print_version
  else
# Actually Print Service Info
#    print_italics "Service File Location: ${SERVICEFILE}"
    print_version
    printline
    [ -f $SERVICEFILE.sorted ] && rm $SERVICEFILE.sorted 2>/dev/null
    sort -k2 --field-separator=: $SERVICEFILE > $SERVICEFILE.sorted
    SORTED=$SERVICEFILE.sorted
    while IFS="" read -r p || [ -n "$p" ]
    do
    DESCRIPTION=$(echo $p | awk -F: '{ print $1 }')
    if [[ $_V -eq 1 ]]; then
      print_italics "$DESCRIPTION"
    fi
    COMMAND=$(echo $p | awk -F: {'first = $1; $1=""; print $0'}|sed 's/: //g')
    [[ ! -z "$IP" ]] && COMMAND="${COMMAND//\$IP/$IP}" 
    [[ ! -z "$IP" ]] && COMMAND="${COMMAND//\$ip/$IP}" 
    [[ ! -z "$PORT" ]] && COMMAND="${COMMAND//\$PORT/$PORT}" 
    [[ ! -z "$PORT" ]] && COMMAND="${COMMAND//\$port/$PORT}" 
    print_good "$COMMAND"
    printline
    done < $SORTED
  fi
  exit
}


function add_service {
  checkForSingleQuotes
  [ ! -f $SERVICEFILE ] && touch $SERVICEFILE
  COMMENT=""
  while [[ $COMMENT == '' ]] # While string is different or empty...
  do
  print_info "Please input a comment about this command"
  read -p 'Comment: ' COMMENT
  done
  echo $COMMENT:${FULLCMD} >> ${SERVICEFILE}
  echo "Appended service command successfully:"
  tail -n 1 ${SERVICEFILE}
  exit 0
}


# start execution
verify_directory_services_exists
  [ $# -eq 0 ]  && usage && exit
  [ $# -eq 1 ] && print_service

  if [[ $_V -eq 1 ]]; then
    print_service
  fi

  if [[ $_A -eq 1 ]]; then
    [ $# -eq 2 ] && print_error "you need to type something to add for ${SERVICE}" && usage2
    [ $# -gt 2 ] && add_service
  fi


